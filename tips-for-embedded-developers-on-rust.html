<!DOCTYPE html>
<html lang="en-GB">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

    <title> Tips for Transitioning Embedded Developers: Leveraging Rust's Power</title>
    <link rel="canonical" href="https://acalustra.com/tips-for-embedded-developers-on-rust.html" />
    <meta name="keywords" content=" Rust, embedded development, C, generics, traits, iterators, cargo workspaces"/>
    <meta name="description" content=" Transitioning from C to Rust in embedded development can be challenging. Learn how to harness Rust's power with generics, traits, iterators, and cargo workspaces to write better code. "/>

    <link rel="stylesheet" type="text/css" href="/theme/css/style.css">
    <link rel="stylesheet" type="text/css" href="/theme/css/pygment.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://acalustra.com/rss.xml" type="application/atom+xml" rel="alternate" title="A Calustra Full Atom Feed" />







    <meta name="tags" content="Rust, embedded development, C, generics, traits, iterators, cargo workspaces" />
    <meta name="date" content=" 2024-02-09 12:00:00+01:00" />
    <meta name="category" content="blog" />
    <meta name="author" content="Eloy coto" />
    <meta name="robots" content="index,follow" />
  </head>
  <body>

    <header>
      <b> A Calustra - Eloy Coto Pereiro </b>
      <a href="/">Home</a>
      <!-- <a href="/blog">Blog</a> -->
      <a href="/pages/about.html">About</a>
    </header>

<article>
  <h1 itemprop="name headline">How to Level Up Your Embedded Rust Skills: A Guide for Transitioning Developers</h1>
  <p>
    <b rel="author">Eloy Coto Pereiro </b>
    on
    <time datetime="2024-02-09T12:00:00" itemprop="datePublished">February 09th, 2024</time>
  </p>


  <div itemprop="articleBody">
    <p>One of my hobbies has been extensively working with Rust in embedded
development. Over time, I've observed that many embedded developers
transitioning from C to Rust often underutilize the language's features,
leaving room for code improvement. Here are some recommendations for those
starting out.</p>
<div class="section" id="not-utilizing-generics-or-traits">
<h2>Not utilizing generics or traits</h2>
<p>Harnessing the power of generics can revolutionize your project. For instance,
I saw a few times, embedding GPIO information into the implementation. This
makes testing trickier and tightly couple the code to the target board, posing
challenges for updating it with new releases.</p>
<p>Consider this example of a motor struct:</p>
<div class="highlight"><pre><span></span><span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Motor</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">action_pin</span>: <span class="nc">gpio</span>::<span class="n">PB6</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">direction_pin</span>: <span class="nc">gpio</span>::<span class="n">PB8</span><span class="w"></span>
<span class="w">    </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>The main issue with this approach is its difficulty in debugging and testing.
The internal structures are tightly coupled to the board-hal structs, limiting
reusability for multiple motors.</p>
<p>An alternative approach is using generics, where the action and direction pins
only need to implement a trait, such as those from embedded_hal.</p>
<div class="highlight"><pre><span></span><span class="k">use</span><span class="w"> </span><span class="n">embedded_hal</span>::<span class="n">digital</span>::<span class="n">v2</span>::<span class="n">OutputPin</span><span class="p">;</span><span class="w"></span>
<span class="k">use</span><span class="w"> </span><span class="n">embedded_hal</span>::<span class="n">PwmPin</span><span class="p">;</span><span class="w"></span>

<span class="k">pub</span><span class="w"> </span><span class="k">struct</span> <span class="nc">Motor</span><span class="o">&lt;</span><span class="n">A</span>: <span class="nc">OutputPin</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>: <span class="nc">OutputPin</span><span class="p">,</span><span class="w"> </span><span class="n">P</span>: <span class="nc">PwmPin</span><span class="o">&lt;</span><span class="n">Duty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u16</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">action_pin</span>: <span class="nc">A</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="n">direction_pin</span>: <span class="nc">B</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="o">..</span><span class="p">.</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This allows for the reuse of the struct with different pins and enables unit
testing without the need for a physical board, as you can see in the following
example:</p>
<div class="highlight"><pre><span></span><span class="k">mod</span> <span class="nn">tests</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="k">super</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">mockall</span>::<span class="n">predicate</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">use</span><span class="w"> </span><span class="n">mockall</span>::<span class="o">*</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="n">mock</span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">      </span><span class="n">FakePin</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="w">      </span><span class="k">impl</span><span class="w"> </span><span class="n">OutputPin</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">FakePin</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">type</span> <span class="nc">Error</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">u32</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="c1">// Required methods</span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">set_low</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">fn</span> <span class="nf">set_high</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="p">(),</span><span class="w"> </span><span class="kt">u32</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">      </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cp">#[test]</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">test_motor_forward</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// given</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">action_pin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MockFakePin</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">action_pin</span><span class="p">.</span><span class="n">expect_set_low</span><span class="p">().</span><span class="n">times</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">returning</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(()));</span><span class="w"></span>
<span class="w">        </span><span class="n">action_pin</span><span class="p">.</span><span class="n">expect_set_high</span><span class="p">().</span><span class="n">times</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">returning</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(()));</span><span class="w"></span>

<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">direction_pin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MockFakePin</span>::<span class="n">new</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">direction_pin</span><span class="p">.</span><span class="n">expect_set_low</span><span class="p">().</span><span class="n">times</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">returning</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(()));</span><span class="w"></span>
<span class="w">        </span><span class="n">direction_pin</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">expect_set_high</span><span class="p">()</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">times</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">returning</span><span class="p">(</span><span class="o">||</span><span class="w"> </span><span class="nb">Ok</span><span class="p">(()));</span><span class="w"></span>

<span class="w">        </span><span class="c1">// when</span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">motor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Motor</span>::<span class="n">new</span><span class="p">(</span><span class="n">action_pin</span><span class="p">,</span><span class="w"> </span><span class="n">direction_pin</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">motor</span><span class="p">.</span><span class="n">forward</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>This setup allows validation that the action and direction pins are called
correctly when <cite>motor.forward()</cite> is invoked. Moreover, in the case of a car
with multiple motors, the same struct can be used to initialize both.</p>
<div class="highlight"><pre><span></span><span class="kd">let</span><span class="w"> </span><span class="n">motor_left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Motor</span>::<span class="n">new</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">gpiob</span><span class="p">.</span><span class="n">pb10</span><span class="p">.</span><span class="n">into_push_pull_output</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">gpiob</span><span class="p">.</span><span class="n">crh</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">gpiob</span><span class="p">.</span><span class="n">pb12</span><span class="p">.</span><span class="n">into_push_pull_output</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">gpiob</span><span class="p">.</span><span class="n">crh</span><span class="p">),</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
<span class="kd">let</span><span class="w"> </span><span class="n">motor_right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Motor</span>::<span class="n">new</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="n">gpiob</span><span class="p">.</span><span class="n">pb9</span><span class="p">.</span><span class="n">into_push_pull_output</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">gpiob</span><span class="p">.</span><span class="n">crh</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">gpiob</span><span class="p">.</span><span class="n">pb8</span><span class="p">.</span><span class="n">into_push_pull_output</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span><span class="w"> </span><span class="n">gpiob</span><span class="p">.</span><span class="n">crh</span><span class="p">),</span><span class="w"></span>
<span class="p">);</span><span class="w"></span>
</pre></div>
<p>Hence, leveraging generics is crucial when transitioning to Rust.</p>
</div>
<div class="section" id="take-advantage-of-iterators">
<h2>Take advantage of iterators</h2>
<p>Iterators are among Rust's best features, providing a functional programming
approach and efficient array iteration.</p>
<p>For example, when sending bits over the wire, if the input data can vary in
size, defining it as an iterator allows reusing the send_data function across
actions:</p>
<p>Consider the following example:</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">action_down_blind</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"></span>
<span class="w">        </span><span class="p">[</span><span class="mh">0x5c</span><span class="p">,</span><span class="w"> </span><span class="mh">0xb3</span><span class="p">,</span><span class="w"> </span><span class="mh">0xff</span><span class="p">,</span><span class="w"> </span><span class="mh">0xbc</span><span class="p">,</span><span class="w"> </span><span class="mh">0xf4</span><span class="p">].</span><span class="n">iter</span><span class="p">(),</span><span class="w"></span>
<span class="w">        </span><span class="p">[</span><span class="mh">0x5c</span><span class="p">,</span><span class="w"> </span><span class="mh">0xb3</span><span class="p">,</span><span class="w"> </span><span class="mh">0xb8</span><span class="p">,</span><span class="w"> </span><span class="mh">0xcb</span><span class="p">,</span><span class="w"> </span><span class="mh">0xf4</span><span class="p">].</span><span class="n">iter</span><span class="p">(),</span><span class="w"></span>
<span class="w">        </span><span class="p">[</span><span class="mh">0x5c</span><span class="p">,</span><span class="w"> </span><span class="mh">0xb3</span><span class="p">,</span><span class="w"> </span><span class="mh">0xb8</span><span class="p">,</span><span class="w"> </span><span class="mh">0xcb</span><span class="p">,</span><span class="w"> </span><span class="mh">0xfe</span><span class="p">,</span><span class="w"> </span><span class="mh">0xff</span><span class="p">,</span><span class="w"> </span><span class="mh">0xbc</span><span class="p">,</span><span class="w"> </span><span class="mh">0xf4</span><span class="p">,</span><span class="w"> </span><span class="mh">0x7f</span><span class="p">].</span><span class="n">iter</span><span class="p">(),</span><span class="w"></span>
<span class="w">    </span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="n">data</span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">send_data</span><span class="p">(</span><span class="n">x</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">send_data</span><span class="o">&lt;&#39;</span><span class="na">a</span><span class="p">,</span><span class="w"> </span><span class="n">I</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span><span class="w"> </span><span class="n">data</span>: <span class="nc">I</span><span class="p">)</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="n">I</span>: <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;&#39;</span><span class="na">a</span><span class="w"> </span><span class="kt">u8</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// do stuff</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>Iterators also excel in terms of memory efficiency. For instance, in the
following code:</p>
<div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">int_to_binary_array</span><span class="p">(</span><span class="n">num</span>: <span class="kt">u8</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="p">[</span><span class="kt">u8</span><span class="p">;</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="k">mut</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="mi">8</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">8</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">result</span><span class="p">[</span><span class="mi">7</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">num</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">result</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">fn</span> <span class="nf">test_iter</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="n">filtered_results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|&amp;&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|&amp;</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="n">int_to_binary_array</span><span class="p">(</span><span class="n">x</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">filtered_results</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="c1">//do stuff</span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
<p>The filter function checks if the modulo of 2 is 0 for each element in the
input. the map function returns its binary representation without allocating
new arrays, thanks to iterators traits from the core crate. The following
sequence diagram explains how it works.</p>
<img alt="" src="img/rust_iterators_diagram.png" />
</div>
<div class="section" id="not-using-cargo-workspaces">
<h2>Not using cargo workspaces</h2>
<p>When operating in non-std mode, unit testing becomes trickier as Rust's testing
framework relies on std crates, and some ARM targets does not have std at all.
My recommendation is to split programs into two packages: one for the
board-specific logic and the other for the main code, importing only
embedded-hal traits as dependencies.</p>
<p>For example, create two folders:</p>
<ul class="simple">
<li><cite>blackpill</cite> for the non-std requirements and target delivery to the board.</li>
<li><cite>libs</cite> for the main code, with the sole <cite>embedded-hal</cite> dependency.</li>
</ul>
<p>Inside the <cite>blackpill/cargo.toml</cite>, a new dependency should be added:</p>
<div class="highlight"><pre><span></span><span class="k">[dependencies]</span><span class="w"></span>
<span class="p">....</span><span class="w"></span>
<span class="n">libs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;../libs/&quot;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
</pre></div>
<p>On the libs section, the following points are important:</p>
<ul class="simple">
<li><em>Skip the non-std requirement when non using test</em>. For that the following
macro can be enabled in the code, so you can take advantage of multiple std
apis.</li>
</ul>
<div class="highlight"><pre><span></span><span class="cp">#![cfg_attr(not(test), no_std)]</span><span class="w"></span>
</pre></div>
<ul class="simple">
<li><em>Your only embedded dependency should be embedded-hal</em>. Aim to work with
public traits and keep as much logic as possible here to decouple your code
from the target board or peripheral.</li>
<li>For any special dependencies not covered by <cite>embedded-hal</cite> traits, consider
creating a trait and implementing it in the board code.</li>
</ul>
<p>Full example of the workspace can be found
<a class="reference external" href="https://github.com/eloycoto/aindustriosa-rs/tree/master/workspaces">here.</a></p>
<p>These are common pitfalls I've observed in embedded Rust code. I hope these
tips help you write better code.</p>
</div>


    <h3>Tags</h3>
    <div class="taglist">
        <span class="tag">
          <a href="/tag/embedded.html" rel="tag">embedded</a>
        </span>
        <span class="tag">
          <a href="/tag/rust.html" rel="tag">Rust</a>
        </span>
    </div><!--tags-->

    <h4>Related articles:</h4>
      <ul>
          <li><a href="/embedded-rust-katas-in-a-industriosa.html">Embedded Rust katas in A Industriosa</a></li>
      </ul>

  </div>
</article></body>